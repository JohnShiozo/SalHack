package me.ionar.salhack.module.exploit;

import me.ionar.salhack.module.Module;
import me.ionar.salhack.module.Value;
import me.ionar.salhack.events.*;
import me.ionar.salhack.events.network.*;
import me.ionar.salhack.*;
import me.ionar.salhack.util.*;

import net.minecraft.util.math.*;
import net.minecraft.entity.*;
import net.minecraft.network.play.client.*;
import net.minecraft.network.*;
import net.minecraft.client.*;
import net.minecraft.network.play.server.*;
import net.minecraft.client.entity.*;

import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;

import scala.util.*;
import java.util.*;

public final class EntityDesync2Module extends Module
{
    Entity entity;
    public final Value<Boolean> Debug;
    public final Value<Boolean> DebugPkt;
    public final Value<Integer> Ticks;
    public final Value<Integer> HClip;
    public final Value<Boolean> AutoClip;
    public final Value<Integer> RemountTimer;
    private Timer m_RemountTimer;
    private boolean ChunksLoaded;
    private BlockPos StartPosition;
    private double startY;
    private java.util.Timer m_Timer;
    private ArrayList<CPacketPlayer> PacketsToIgnore;
    
    public EntityDesync2Module() {
        super("EntityDesync2", new String[] { "EntityDesync2" }, "Clientside dismount from entity", "NONE", -1, ModuleType.EXPLOIT);
        this.entity = null;
        this.Debug = new Value<Boolean>("Debug", new String[] { "Debug" }, "Debug msgs", false);
        this.DebugPkt = new Value<Boolean>("DebugPkt", new String[] { "Debug" }, "Debug msgs", false);
        this.Ticks = new Value<Integer>("Tick", new String[] { "Ticks" }, "How many packets to send per tick", 1, 0, 10, 1);
        this.HClip = new Value<Integer>("HClip", new String[] { "HClip" }, "HClip Amount", 80, 0, 150, 10);
        this.AutoClip = new Value<Boolean>("AutoClip", new String[] { "AutoClip" }, "Doesn't waste time and automatically clips forward", false);
        this.RemountTimer = new Value<Integer>("RemountTimer", new String[] { "RemountTimer" }, "Remount Timer", 10000, 0, 20000, 1000);
        this.m_RemountTimer = new Timer();
        this.ChunksLoaded = false;
        this.StartPosition = null;
        this.startY = 0.0;
        this.m_Timer = new java.util.Timer();
        this.PacketsToIgnore = new ArrayList<CPacketPlayer>();
    }
    
    @Listener
    public void SendPacket(final EventSendPacket event) {
        if (event.getStage() != EventStageable.EventStage.PRE) {
            return;
        }
        if (event.getPacket() instanceof CPacketPlayer) {
            final CPacketPlayer l_Packet = (CPacketPlayer)event.getPacket();
            if (this.PacketsToIgnore.contains(l_Packet)) {
                this.PacketsToIgnore.remove(l_Packet);
            }
        }
    }
    
    @Listener
    public void receivePacket(final EventReceivePacket event) {
        if (event.getStage() != EventStageable.EventStage.PRE) {
            return;
        }
        if (event.getPacket() instanceof SPacketSetPassengers) {
            final SPacketSetPassengers sPacketSetPassengers = (SPacketSetPassengers)event.getPacket();
            if (sPacketSetPassengers.getEntityId() != this.entity.getEntityId()) {
                return;
            }
            this.entity.isDead = false;
            this.mc.world.spawnEntity(this.entity);
            this.mc.player.startRiding(this.entity, true);
            this.entity = null;
            this.ToggleOnlySuper();
            SalHack.INSTANCE.logChat("Entity is now null SPacketSetPassengers, toggled off");
        }
        else if (event.getPacket() instanceof SPacketDestroyEntities) {
            final SPacketDestroyEntities l_Packet = (SPacketDestroyEntities)event.getPacket();
            for (final int l_EntityId : l_Packet.getEntityIDs()) {
                if (l_EntityId == this.entity.getEntityId()) {
                    this.entity = null;
                    SalHack.INSTANCE.logChat("Entity is now null SPacketDestroyEntities");
                    break;
                }
            }
        }
        else if (event.getPacket() instanceof SPacketMoveVehicle) {
            final EntityPlayerSP player = Minecraft.getMinecraft().player;
            final SPacketMoveVehicle l_Packet2 = (SPacketMoveVehicle)event.getPacket();
            if (this.DebugPkt.getValue()) {
                SalHack.INSTANCE.logChat("RECV: SPacketMoveVehicle: with data: " + new BlockPos(l_Packet2.getX(), l_Packet2.getY(), l_Packet2.getZ()).toString());
            }
            if (this.entity == null) {
                return;
            }
        }
        else if (event.getPacket() instanceof SPacketPlayerPosLook) {
            final SPacketPlayerPosLook packet = (SPacketPlayerPosLook)event.getPacket();
            this.toggle();
        }
    }
    
    @Override
    public void OnTick() {
        final EntityPlayerSP player = this.mc.player;
        if (player == null) {
            return;
        }
        if (this.entity == null || player.isRiding()) {
            return;
        }
        for (int l_I = 0; l_I < this.Ticks.getValue(); ++l_I) {
            final CPacketPlayer l_Packet = (CPacketPlayer)new CPacketPlayer.Rotation(player.rotationYaw, player.rotationPitch, player.onGround);
            this.PacketsToIgnore.add(l_Packet);
            final Random rand = new Random(2);
            this.entity.setPosition(player.posX, this.startY, player.posZ);
            player.connection.sendPacket((Packet)new CPacketVehicleMove(this.entity));
            if (this.Debug.getValue()) {
                SalHack.INSTANCE.logChat("Update: Sent packet with data: " + this.entity.getPosition().toString());
            }
        }
    }
    
    @Override
    public void onEnable() {
        super.onEnable();
        this.PacketsToIgnore.clear();
        if (this.mc.player == null) {
            this.toggle();
            return;
        }
        if (this.mc.player.getRidingEntity() == null) {
            SalHack.INSTANCE.logChat("You are not riding an entity.");
            this.ToggleOnlySuper();
            return;
        }
        this.ChunksLoaded = false;
        this.startY = this.mc.player.getRidingEntity().posY;
        this.DismountEntity();
        this.StartPosition = new BlockPos(this.mc.player.posX, this.mc.player.posY, this.mc.player.posZ);
        this.m_Timer = new java.util.Timer();
        if (this.AutoClip.getValue()) {
            SalHack.INSTANCE.logChat("Clipping... and spamming packets in 1s");
            this.m_Timer.schedule(new TimerTask() {
                @Override
                public void run() {
                    final Vec3d l_Direction = MathUtil.direction(EntityDesync2Module.this.mc.player.rotationYaw);
                    EntityDesync2Module.this.mc.player.setPosition(EntityDesync2Module.this.mc.player.posX + l_Direction.x * EntityDesync2Module.this.HClip.getValue(), EntityDesync2Module.this.mc.player.posY, EntityDesync2Module.this.mc.player.posZ + l_Direction.z * EntityDesync2Module.this.HClip.getValue());
                }
            }, 50L);
        }
    }
    
    @Override
    public void onDisable() {
        super.onDisable();
        this.m_Timer = null;
        this.m_RemountTimer = null;
        if (this.entity != null) {
            this.RemountEntity();
        }
        else if (this.mc != null && this.mc.player != null) {
            SalHack.INSTANCE.logChat("Entity was null...");
        }
    }
    
    public void DismountEntity() {
        this.entity = this.mc.player.getRidingEntity();
        this.mc.player.dismountRidingEntity();
        this.mc.world.removeEntity(this.entity);
        SalHack.INSTANCE.logChat("Forced a dismount.");
    }
    
    public void RemountEntity() {
        if (this.entity != null && this.mc.player.getRidingEntity() != null) {
            SalHack.INSTANCE.logChat("You are already mounted..");
            return;
        }
        SalHack.INSTANCE.logChat("Forced a remount.");
        this.entity.isDead = false;
        this.mc.world.spawnEntity(this.entity);
        this.mc.player.startRiding(this.entity, true);
    }
}